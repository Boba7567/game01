<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>鳥居くぐり</title>
    <link href="https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&display=swap" rel="stylesheet">
    <style>
        :root {
            --japan-blue: #2c3e50;
            --japan-red: #c0392b;
            --japan-white: #fffaf0;
            --japan-cream: #fceebb;
            --japan-shadow: rgba(0,0,0,0.3);
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: var(--japan-blue);
            touch-action: none;
            font-family: 'Sawarabi Mincho', serif;
            -webkit-user-select: none; color: #fff;
        }
        #game-container { position: absolute; top:0; left:0; width:100%; height:100%; }
        canvas { display: block; width:100%; height:100%; }
        #ui-layer {
            position: absolute; top:0; left:0; width:100%; height:100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
        }

        #score-display {
            margin-top: 10vh; font-size: 4rem; font-weight: bold;
            color: var(--japan-cream);
            text-shadow: 3px 3px 0 #8e44ad;
        }

        .panel {
            background-color: var(--japan-white);
            border: 6px double var(--japan-red);
            padding: 30px 40px; text-align: center; border-radius: 8px;
            pointer-events: auto; box-shadow: 0 10px 20px var(--japan-shadow);
            color: var(--japan-blue);
            position: absolute; top: 50%; transform: translateY(-50%);
            min-width: 260px;
        }
        #start-screen h1 { font-size: 3rem; color: var(--japan-red); margin: 0 0 15px 0; letter-spacing: 0.1em; }
        #start-screen p { font-size: 1.2rem; font-weight: bold; margin: 8px 0; }
        #result-screen { display: none; }
        .score-val { font-size: 1.5rem; color: var(--japan-red); }
        .btn {
            background: var(--japan-red); color: var(--japan-white); border: none;
            padding: 12px 30px; font-size: 1.3rem; font-family: 'Sawarabi Mincho', serif;
            cursor: pointer; margin-top: 20px; border-radius: 4px;
            box-shadow: 0 4px #922b21; transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 0 #922b21; }
        #new-record { display: none; color: #d35400; font-size: 1rem; margin-bottom: 5px; font-weight: bold; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="score-display">0</div>
        <div id="start-screen" class="panel">
            <h1>鳥居くぐり</h1><p>画面をタップして飛ぶ</p>
        </div>
        <div id="result-screen" class="panel">
            <div id="new-record">祝！新記録達成</div>
            <h1>終劇</h1>
            <p>記録: <span id="final-score" class="score-val">0</span></p>
            <p>最高記録: <span id="best-score" class="score-val">0</span></p>
            <button id="retry-btn" class="btn">もう一度</button>
        </div>
    </div>
</div>

<script>
    // --- 音響設定 (Web Audio API) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function resumeAudio() { if (audioCtx.state === 'suspended') audioCtx.resume(); }
    
    function playSound(type) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);

        if (type === 'jump') {
            // 羽音
            const bufferSize = audioCtx.sampleRate * 0.2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, now); filter.frequency.linearRampToValueAtTime(100, now + 0.2);
            noise.connect(filter); filter.connect(masterGain);
            masterGain.gain.setValueAtTime(0, now); masterGain.gain.linearRampToValueAtTime(0.6, now + 0.02);
            masterGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            noise.start(now); noise.stop(now + 0.2);

        } else if (type === 'score') {
            // 小鼓
            const osc = audioCtx.createOscillator(); osc.type = 'sine';
            osc.frequency.setValueAtTime(450, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.05); 
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.2); 
            const clickOsc = audioCtx.createOscillator(); clickOsc.type = 'square'; clickOsc.frequency.value = 200;
            const clickGain = audioCtx.createGain(); clickGain.gain.setValueAtTime(0.2, now);
            clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            osc.connect(masterGain); clickOsc.connect(clickGain); clickGain.connect(masterGain);
            masterGain.gain.setValueAtTime(0, now); masterGain.gain.linearRampToValueAtTime(0.8, now + 0.01);
            masterGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            osc.start(now); osc.stop(now + 0.25); clickOsc.start(now); clickOsc.stop(now + 0.1);

        } else if (type === 'highscore') {
            // 琴
            const pentatonic = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51, 1567.98];
            pentatonic.forEach((freq, i) => {
                const startTime = now + i * 0.06; const osc = audioCtx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = freq;
                const noteGain = audioCtx.createGain(); noteGain.connect(masterGain);
                noteGain.gain.setValueAtTime(0, startTime); noteGain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + 1.5);
                osc.connect(noteGain); osc.start(startTime); osc.stop(startTime + 1.5);
            });
            masterGain.gain.value = 1.0;

        } else if (type === 'hit') {
            // 梵鐘
            masterGain.gain.setValueAtTime(0.5, now); masterGain.gain.exponentialRampToValueAtTime(0.001, now + 4.0);
            const baseFreq = 160; const harmonics = [1, 1.3, 1.7, 2.5, 3.8]; const gains = [1, 0.6, 0.4, 0.2, 0.1];
            harmonics.forEach((h, i) => {
                const osc = audioCtx.createOscillator(); osc.type = i === 0 ? 'sine' : 'triangle';
                osc.frequency.value = baseFreq * h; if (i > 0) osc.detune.value = Math.random() * 10 - 5; 
                const oscGain = audioCtx.createGain(); oscGain.gain.value = gains[i];
                osc.connect(oscGain); oscGain.connect(masterGain); osc.start(now); osc.stop(now + 4.0);
            });

        } else if (type === 'splash') {
            // 水音
            const bufferSize = audioCtx.sampleRate * 0.4;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.8; 
            const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1500, now); filter.frequency.exponentialRampToValueAtTime(200, now + 0.3);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(1.0, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            noise.connect(filter); filter.connect(gain); gain.connect(masterGain);
            noise.start(now);
        }
    }

    // --- ゲーム設定 ---
    // もっさり解消のため、ベーススピードと重力を少し強化
    const BASE_CONFIG = {
        gravity: 0.7, // 0.6 -> 0.7 (キビキビさせる)
        jumpStrength: -9.5,
        speed: 4.2,   // 3.0 -> 4.2 (疾走感アップ)
        pipeSpawnRate: 140, 
        pipeGap: 190,
        pipeWidth: 70,
        birdSize: 20
    };

    let CONFIG = { ...BASE_CONFIG, groundHeight: 0 };
    let gameScale = 1.0;

    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    // 高速描画用のオフスクリーンキャンバス（背景キャッシュ用）
    const bgCanvas = document.createElement('canvas'); const bgCtx = bgCanvas.getContext('2d');

    const scoreDisplay=document.getElementById('score-display'); const startScreen=document.getElementById('start-screen');
    const resultScreen=document.getElementById('result-screen'); const finalScoreEl=document.getElementById('final-score');
    const bestScoreEl=document.getElementById('best-score'); const newRecordEl=document.getElementById('new-record');
    const retryBtn=document.getElementById('retry-btn');
    let frames=0, score=0, state='START', width, height;
    let bestScore = localStorage.getItem('flappyToriiBest') || 0;
    let groundOffset = 0; let sakuraParticles = [];

    // 時間管理用変数 (Delta Time)
    let lastTime = 0;
    let accumulator = 0;
    const TARGET_FPS = 60;
    const STEP = 1000 / TARGET_FPS;

    class Sakura {
        constructor() { this.reset(); }
        reset() {
            this.x = Math.random() * width; this.y = -10; 
            this.size = (Math.random() * 5 + 3) * gameScale;
            this.speedX = (Math.random() - 0.5) * gameScale;
            this.speedY = (Math.random() + 0.5) * gameScale;
            this.rotation = Math.random() * Math.PI * 2; this.rotationSpeed = Math.random() * 0.05 - 0.025;
        }
        update(dt) { // dtを使って移動量を正規化
            this.x += this.speedX * dt; 
            this.y += this.speedY * dt; 
            this.rotation += this.rotationSpeed * dt;
            if (this.y > height) this.reset();
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
            ctx.fillStyle = 'rgba(255, 183, 197, 0.8)'; ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
        }
    }

    let bird;

    function resize() {
        width = window.innerWidth; 
        height = window.innerHeight;
        canvas.width = width; 
        canvas.height = height;
        
        // 背景用キャンバスもリサイズ
        bgCanvas.width = width;
        bgCanvas.height = height;

        const baseWidth = 400;
        gameScale = Math.min(width, height) / baseWidth;
        if (gameScale < 0.8) gameScale = 0.8; 
        if (gameScale > 1.5) gameScale = 1.5; // iPad向けにスケールしすぎないよう制限（相対的に速く感じるように）

        CONFIG.gravity = BASE_CONFIG.gravity * gameScale;
        CONFIG.jumpStrength = BASE_CONFIG.jumpStrength * gameScale;
        CONFIG.speed = BASE_CONFIG.speed * gameScale;
        CONFIG.pipeGap = BASE_CONFIG.pipeGap * gameScale;
        CONFIG.pipeWidth = BASE_CONFIG.pipeWidth * gameScale;
        CONFIG.birdSize = BASE_CONFIG.birdSize * gameScale;
        CONFIG.groundHeight = height * 0.15;

        if (bird) {
            bird.x = width * 0.3;
            bird.size = CONFIG.birdSize;
            bird.r = CONFIG.birdSize * 0.75;
        }
        
        sakuraParticles = []; for(let i=0; i<30; i++) sakuraParticles.push(new Sakura());
        
        // 背景をキャッシュに描画（毎フレームの負荷を減らす）
        renderStaticBackground();
    }
    window.addEventListener('resize', resize);

    // --- 静的背景の事前描画（高速化の肝） ---
    function renderStaticBackground() {
        const grad = bgCtx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, '#1a2a6c'); grad.addColorStop(0.6, '#b21f1f'); grad.addColorStop(1, '#fdbb2d');
        bgCtx.fillStyle = grad; bgCtx.fillRect(0, 0, width, height);
        
        const mountainY = height - CONFIG.groundHeight;
        const fujiCenterX = width * 0.5; const fujiHeight = height * 0.35; const fujiWidth = width * 0.8;
        bgCtx.fillStyle = '#2c3e50'; 
        bgCtx.beginPath(); bgCtx.moveTo(fujiCenterX - fujiWidth/2, mountainY);
        bgCtx.bezierCurveTo(fujiCenterX - fujiWidth/4, mountainY - fujiHeight*0.5, fujiCenterX, mountainY - fujiHeight, fujiCenterX, mountainY - fujiHeight);
        bgCtx.bezierCurveTo(fujiCenterX, mountainY - fujiHeight, fujiCenterX + fujiWidth/4, mountainY - fujiHeight*0.5, fujiCenterX + fujiWidth/2, mountainY);
        bgCtx.closePath(); bgCtx.fill();
        bgCtx.fillStyle = '#fffaf0';
        bgCtx.beginPath(); bgCtx.moveTo(fujiCenterX, mountainY - fujiHeight);
        bgCtx.lineTo(fujiCenterX + fujiWidth*0.1, mountainY - fujiHeight*0.8);
        bgCtx.lineTo(fujiCenterX + fujiWidth*0.05, mountainY - fujiHeight*0.75);
        bgCtx.lineTo(fujiCenterX, mountainY - fujiHeight*0.85);
        bgCtx.lineTo(fujiCenterX - fujiWidth*0.05, mountainY - fujiHeight*0.75);
        bgCtx.lineTo(fujiCenterX - fujiWidth*0.1, mountainY - fujiHeight*0.8);
        bgCtx.closePath(); bgCtx.fill();
        bgCtx.fillStyle = 'rgba(255, 250, 240, 0.3)';
        bgCtx.beginPath(); bgCtx.moveTo(0, mountainY-50);
        bgCtx.bezierCurveTo(width/3, mountainY-100, width*2/3, mountainY, width, mountainY-50);
        bgCtx.lineTo(width, mountainY); bgCtx.lineTo(0, mountainY); bgCtx.fill();
    }

    function drawGround(dt) { // dt対応
        const gh = CONFIG.groundHeight; const gy = height - gh;
        const waterGrad = ctx.createLinearGradient(0, gy, 0, height);
        waterGrad.addColorStop(0, '#3a5f78'); waterGrad.addColorStop(1, '#1b2a40');
        ctx.fillStyle = waterGrad; ctx.fillRect(0, gy, width, gh);
        
        // dtを使ってスクロール量を計算
        if (state === 'PLAYING') groundOffset = (groundOffset + (CONFIG.speed * 0.8) * dt) % (100 * gameScale);
        
        ctx.strokeStyle = 'rgba(255, 250, 240, 0.2)'; 
        ctx.lineWidth = 2 * gameScale; 
        ctx.beginPath();
        const waveW = 100 * gameScale;
        const waveH = 5 * gameScale;
        for (let y = gy + 10; y < height; y += 20 * gameScale) {
            for (let x = -groundOffset; x < width; x += waveW) {
                ctx.moveTo(x, y); 
                ctx.quadraticCurveTo(x + waveW*0.3, y - waveH, x + waveW*0.5, y); 
                ctx.quadraticCurveTo(x + waveW*0.7, y + waveH, x + waveW, y);
            }
        }
        ctx.stroke();
        ctx.fillStyle = '#fceebb';
        const speckCount = Math.floor(width / (30 * gameScale));
        for(let i=0; i<speckCount; i++) {
            let sx = (i * 1234 + groundOffset * 0.5) % width; let sy = gy + (i * 5678) % gh;
            let size = ((i % 3) + 1) * gameScale; ctx.fillRect(sx, sy, size, size);
        }
        ctx.fillStyle = '#fffaf0'; ctx.fillRect(0, gy, width, 3 * gameScale);
    }

    bird = {
        x:0, y:200, size:20, velocity:0, r:15,
        draw() {
            let rotation = Math.min(Math.PI/4, Math.max(-Math.PI/4, (this.velocity * 0.08)));
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(rotation);
            const bodyWhite = '#fffaf0'; const featherBlack = '#2c3e50'; const headRed = '#c0392b';
            const s = this.size; 

            ctx.fillStyle = bodyWhite; ctx.beginPath();
            ctx.moveTo(s*0.25, 0); ctx.quadraticCurveTo(s*-0.5, s*-1, s*-1.25, s*-0.25); ctx.quadraticCurveTo(s*-0.75, s*-0.25, s*-0.25, s*0.25); ctx.fill();
            ctx.fillStyle = featherBlack; ctx.beginPath();
            ctx.moveTo(s*-0.75, s*-0.6); ctx.quadraticCurveTo(s*-1.25, s*-0.25, s*-0.9, s*-0.1); ctx.fill();
            ctx.fillStyle = bodyWhite; ctx.beginPath(); ctx.ellipse(0, s*0.25, s*0.75, s*0.4, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(s*0.5, s*0.25); ctx.quadraticCurveTo(s, 0, s*1.25, s*-0.5); ctx.lineTo(s*1.6, s*-0.4); ctx.lineTo(s*1.4, s*-0.75); ctx.lineTo(s*1.1, s*-0.6); ctx.fill();
            ctx.fillStyle = featherBlack; ctx.beginPath(); ctx.moveTo(s*0.75, s*0.1); ctx.quadraticCurveTo(s, s*-0.25, s*1.1, s*-0.6); ctx.lineTo(s*0.9, s*-0.5); ctx.quadraticCurveTo(s*0.75, s*-0.1, s*0.6, s*0.25); ctx.fill();
            ctx.fillStyle = headRed; ctx.beginPath(); ctx.arc(s*1.4, s*-0.7, s*0.125, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = bodyWhite; ctx.beginPath();
            if (this.velocity < 0) { ctx.moveTo(s*0.25, s*0.25); ctx.quadraticCurveTo(s*-0.5, s*1.25, s*-1.25, s*0.75); ctx.quadraticCurveTo(s*-0.75, s*0.5, s*-0.25, s*0.5); } 
            else { ctx.moveTo(s*0.25, s*0.25); ctx.quadraticCurveTo(s*-0.75, s*0.25, s*-1.5, 0); ctx.quadraticCurveTo(s*-0.75, 0, s*-0.25, s*0.4); }
            ctx.fill();
            ctx.fillStyle = featherBlack; ctx.beginPath();
            if (this.velocity < 0) { ctx.moveTo(s*-0.75, s*0.9); ctx.quadraticCurveTo(s*-1.25, s*0.75, s*-1, s*0.5); }
            else { ctx.moveTo(s*-1, s*0.15); ctx.quadraticCurveTo(s*-1.5, 0, s*-1.1, s*-0.1); }
            ctx.fill();
            ctx.restore();
        },
        update(dt) {
            // dtを使った物理計算
            this.velocity += CONFIG.gravity * dt; 
            this.y += this.velocity * dt;
            if(this.y + this.r >= height - CONFIG.groundHeight) gameOver('water');
        },
        jump() { this.velocity = CONFIG.jumpStrength; playSound('jump'); }
    };

    function drawTorii(x, y, w, h, isTop) {
        const redDark = '#922b21', redLight = '#c0392b', black = '#2c3e50';
        const colW = 15 * gameScale;
        const barH = 12 * gameScale;
        const curH = 20 * gameScale;

        const pillarGrad = ctx.createLinearGradient(x, 0, x + colW, 0);
        pillarGrad.addColorStop(0, redDark); pillarGrad.addColorStop(0.5, redLight); pillarGrad.addColorStop(1, redDark);
        ctx.fillStyle = pillarGrad; ctx.fillRect(x + w*0.15, y, colW, h);
        const pillarGradRight = ctx.createLinearGradient(x + w - w*0.15 - colW, 0, x + w - w*0.15, 0);
        pillarGradRight.addColorStop(0, redDark); pillarGradRight.addColorStop(0.5, redLight); pillarGradRight.addColorStop(1, redDark);
        ctx.fillStyle = pillarGradRight; ctx.fillRect(x + w - w*0.15 - colW, y, colW, h);
        
        const crossBarY = isTop ? h - 45 * gameScale : y + 25 * gameScale;
        const kasagiGrad = ctx.createLinearGradient(0, crossBarY - curH, 0, crossBarY);
        kasagiGrad.addColorStop(0, redLight); kasagiGrad.addColorStop(1, redDark);
        ctx.fillStyle = kasagiGrad; ctx.beginPath(); ctx.moveTo(x - 5*gameScale, crossBarY);
        ctx.bezierCurveTo(x + w / 2, crossBarY + 15*gameScale, x + w / 2, crossBarY + 15*gameScale, x + w + 5*gameScale, crossBarY);
        ctx.lineTo(x + w + 10*gameScale, crossBarY - curH);
        ctx.bezierCurveTo(x + w / 2, crossBarY - 5*gameScale, x + w / 2, crossBarY - 5*gameScale, x - 10*gameScale, crossBarY - curH);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = redLight; ctx.fillRect(x + 5*gameScale, crossBarY + 25*gameScale, w - 10*gameScale, barH);
        ctx.fillStyle = black; ctx.fillRect(x + w / 2 - 6*gameScale, crossBarY + 5*gameScale, 12*gameScale, curH);
    }

    const pipes = {
        items:[], reset(){this.items=[]},
        update(dt) {
            // スポーンタイミングの管理（dtベース）
            // ここは簡易的にフレームカウントのままにするが、移動はdtを使う
            if(frames % CONFIG.pipeSpawnRate === 0){
                const groundY = height - CONFIG.groundHeight; 
                const minH = 90 * gameScale; 
                const maxH = groundY - CONFIG.pipeGap - minH;
                const topH = Math.floor(Math.random() * (maxH - minH + 1) + minH);
                this.items.push({x:width, w:CONFIG.pipeWidth, h:topH, passed:false});
            }
            for(let i=0; i<this.items.length; i++){
                let p=this.items[i]; 
                p.x -= CONFIG.speed * dt; // dt対応
                let bottomY = p.h + CONFIG.pipeGap;
                
                const padding = 15 * gameScale;
                if(bird.x + bird.r > p.x + padding && 
                   bird.x - bird.r < p.x + p.w - padding && 
                   (bird.y - bird.r < p.h || bird.y + bird.r > bottomY)) gameOver('hit');
                
                if(p.x + p.w < bird.x && !p.passed){ 
                    score++; scoreDisplay.innerText=score; p.passed=true; playSound('score'); 
                }
            }
            if(this.items.length > 0 && this.items[0].x < -150 * gameScale) this.items.shift();
        },
        draw() {
            for(let p of this.items){
                let by = p.h + CONFIG.pipeGap; let gy = height - CONFIG.groundHeight;
                drawTorii(p.x, 0, p.w, p.h, true); drawTorii(p.x, by, p.w, gy - by, false);
            }
        }
    };

    // --- メインループ (Delta Time 対応) ---
    function loop(timestamp) {
        // Delta Time計算
        if (!lastTime) lastTime = timestamp;
        const deltaTimeMs = timestamp - lastTime;
        lastTime = timestamp;
        
        // 60FPSを基準(1.0)とした係数。120Hzなら0.5になる。
        const dt = deltaTimeMs / (1000 / 60);

        // 描画
        ctx.clearRect(0, 0, width, height);
        // 背景はキャッシュから描画（高速化）
        ctx.drawImage(bgCanvas, 0, 0);
        
        // 桜は動かす
        sakuraParticles.forEach(p => { p.update(dt); p.draw(); });

        if(state==='PLAYING'){
            pipes.update(dt);
            bird.update(dt);
            frames++;
        }
        
        pipes.draw(); 
        drawGround(dt); // 地面もdt対応
        if(state!=='START') bird.draw();
        
        requestAnimationFrame(loop);
    }

    function startGame() {
        state='PLAYING'; bird.y=height/3; bird.velocity=0; pipes.reset();
        score=0; scoreDisplay.innerText=score; scoreDisplay.style.display='block';
        startScreen.style.display='none'; resultScreen.style.display='none';
        frames=0; resumeAudio(); sakuraParticles.forEach(p=>p.reset());
        lastTime = 0; // タイマーリセット
    }
    
    function gameOver(cause) {
        if(state!=='GAMEOVER'){
            state='GAMEOVER'; 
            let isNew=false; 
            if(score>bestScore){
                bestScore=score; localStorage.setItem('flappyToriiBest',bestScore); isNew=true;
            }
            if(isNew && score > 0) {
                playSound('highscore');
            } else {
                playSound('hit');
                if (cause === 'water') {
                    setTimeout(() => { playSound('splash'); }, 100);
                }
            }
            scoreDisplay.style.display='none'; finalScoreEl.innerText=score; bestScoreEl.innerText=bestScore;
            newRecordEl.style.display=isNew?'block':'none'; resultScreen.style.display='block';
        }
    }
    function onInput(e){if(e.target.closest('.btn'))return; if(e.cancelable)e.preventDefault(); if(state==='START')startGame(); else if(state==='PLAYING')bird.jump();}
    retryBtn.addEventListener('click',startGame); retryBtn.addEventListener('touchstart',e=>{e.stopPropagation();startGame();});
    window.addEventListener('touchstart',onInput,{passive:false}); window.addEventListener('mousedown',onInput); window.addEventListener('keydown',e=>{if(e.code==='Space')onInput(e);});
    
    // 初回実行
    resize(); 
    bird.x=width*0.3; 
    requestAnimationFrame(loop); // loop開始
</script>
</body>
</html>
